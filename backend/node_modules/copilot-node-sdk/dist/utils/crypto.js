import * as crypto from 'crypto';
/**
 * This function generates a sha 256 and returns the first
 * half of that string. This should be a safe operation, the
 * odds of a collision are exceedingly low.
 * @param apiKey
 * @returns
 */
export function generate128BitKey(apiKey) {
  // TODO: I think we can use full 256 bit keys for this.
  //       That change will have to coordinate with
  //       a change to the token creation in the go codebase.
  const mac = crypto.createHmac('sha256', apiKey).digest('hex');
  return mac.slice(0, 32);
}
/**
 * This function decrypts the AES encrypted generated by the Copilot backend.
 * @param key              A 128 bit key, typically generated by passing
 *                         an API key to the `generate128BitKey` function.
 * @param encryptedMessage The AES encrypted message.
 * @returns                The decrypted string.
 */
export function decryptAES128BitToken(key, encryptedMessage) {
  if (process.env.COPILOT_DEBUG) {
    console.log({ key, encryptedMessage });
  }
  // Convert the key to a Buffer
  const keyBuffer = Buffer.from(key, 'hex');
  // Convert the encryptedMessage to a Buffer
  const encryptedBuffer = Buffer.from(encryptedMessage, 'hex');
  // Extract the IV from the encrypted message
  const iv = encryptedBuffer.subarray(0, 16); // Assuming the IV length is 16 bytes (AES block size)
  // Extract the ciphertext from the encrypted message
  const ciphertext = encryptedBuffer.subarray(16);
  // Create a new AES cipher block
  const decipher = crypto.createDecipheriv('aes-128-cbc', keyBuffer, iv);
  // Decrypt the ciphertext
  let decrypted = decipher.update(ciphertext);
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  return decrypted.toString('utf-8');
}
//# sourceMappingURL=crypto.js.map
